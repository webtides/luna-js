import path from "path";
import fs from "fs";
import deepmerge from "deepmerge";
import defaultSettings from "./config/default.config";
import {normalizeDomainAndContext} from "./helpers/normalize";

let settings = false;

class Configuration {
    settings = null;

    /**
     * Loads the manifest generated by the cli.
     *
     * @param filename      Can either be the `manifest.json` or `manifest.client.json`, depending
     *                       of the manifest that should be loaded.
     *
     * @returns {Promise<boolean|any>}
     */
    async loadManifest(filename = "manifest.json") {
        const path = await import('path');
        const fs = await import('fs');

        const settings = await loadSettings();

        const pathToManifest = path.join(settings._generated.baseDirectory, filename);

        if (fs.existsSync(pathToManifest)) {
            return JSON.parse(fs.readFileSync(pathToManifest, "utf-8"));
        }

        return false;
    }

    /**
     * Used to retrieve the path to the `luna.config.js`.
     *
     * @param currentWorkingDirectory string
     *
     * @returns {string}
     */
    getPathToConfigFile(currentWorkingDirectory = process.cwd()) {
        return path.join(currentWorkingDirectory, "luna.config.js");
    }

    /**
     * This method parses user settings from the `luna.config.js`.
     * Adds some more fields for generated paths. Anything that the user
     * can set or change should come from this settings object.
     *
     * @returns {Promise<*|boolean>}
     */
    async loadSettings() {
        if (this.settings !== null) {
            return this.settings;
        }

        try {
            const settings = deepmerge(defaultSettings, (await import(getPathToConfigFile())).default);

            settings.publicDirectory = path.join(settings.build.output, "public");

            settings._generated = {
                baseDirectory: path.join(settings.build.output, "generated"),
                applicationDirectory: path.join(settings.build.output, "generated", "application"),

                manifest: path.join(settings.build.output, "generated", "manifest.json"),
                clientManifest: path.join(settings.build.output, "generated", "manifest.client.json"),
            }

            /*
             * The cli sets the global flag isExporting if the user initialized an export.
             * Here we override the api and assets settings with the specific export settings.
             */
            // TODO: find some kind of plugin system to "connect" the cli and luna
            if (global.lunaCli?.isExporting === true) {
                settings.api = Object.assign(settings.api, settings.export?.api ?? {});
                settings.assets = Object.assign(settings.assets, settings.export?.assets ?? {});
            }

            settings.api = normalizeDomainAndContext(settings.api);
            settings.assets = normalizeDomainAndContext(settings.assets);

            this.settings = settings;

            return settings;
        } catch (error) {
            console.error(error);
            return false;
        }
    }

    getConfig() {
        return this.settings;
    }

    getConfigValue(key, defaultValue = false) {
        const parts = key.split('.');

        let setting = this.getSettings();
        for (const part of parts) {
            if (setting[part]) {
                setting = setting[part];
            } else {
                return defaultValue;
            }
        }
        return setting;
    }

    /**
     * Takes the fields from the settings object that can be
     * serialized and shared between server and client.
     *
     * @returns {boolean|{assets: {domain: *, context: string}, api: {domain: *, context: string}}}
     */
    serialize() {
        if (!this.settings) {
            return false;
        }

        const settings = this.getSettings();

        return {
            port: settings.port,

            assets: {
                domain: settings.assets.domain,
                context: settings.assets.context,
            },

            api: {
                domain: settings.api.domain,
                context: settings.api.context,
            }
        }
    };
}

/**
 * Loads the manifest generated by the cli.
 *
 * @param filename      Can either be the `manifest.json` or `manifest.client.json`, depending
*                       of the manifest that should be loaded.
 *
 * @returns {Promise<boolean|any>}
 */
const loadManifest = async (filename = "manifest.json") => {
    const settings = await loadSettings();

    const pathToManifest = path.join(settings._generated.baseDirectory, filename);

    if (fs.existsSync(pathToManifest)) {
        return JSON.parse(fs.readFileSync(pathToManifest, "utf-8"));
    }

    return false;
};

/**
 * Used to retrieve the path to the `luna.config.js`.
 *
 * @param currentWorkingDirectory string
 *
 * @returns {string}
 */
const getPathToConfigFile = (currentWorkingDirectory = process.cwd()) => {
    return path.join(currentWorkingDirectory, "luna.config.js");
}

/**
 * This method parses user settings from the `luna.config.js`.
 * Adds some more fields for generated paths. Anything that the user
 * can set or change should come from this settings object.
 *
 * @param {{ config: any }}
 * @returns {Promise<*|boolean>}
 */
const loadSettings = async ({ config } = {}) => {
    if (settings) {
        return settings;
    }

    try {
        settings = config
            ? deepmerge(defaultSettings, config)
            : deepmerge(defaultSettings, (await import(getPathToConfigFile())).default);

        settings.publicDirectory = path.join(settings.build.output, "public");

        settings._generated = {
            baseDirectory: path.join(settings.build.output, "generated"),
            applicationDirectory: path.join(settings.build.output, "generated", "application"),

            manifest: path.join(settings.build.output, "generated", "manifest.json"),
            clientManifest: path.join(settings.build.output, "generated", "manifest.client.json"),
        }

        /*
         * The cli sets the global flag isExporting if the user initialized an export.
         * Here we override the api and assets settings with the specific export settings.
         */
        // TODO: find some kind of plugin system to "connect" the cli and luna
        if (global.lunaCli?.isExporting === true) {
            settings.api = Object.assign(settings.api, settings.export?.api ?? {});
            settings.assets = Object.assign(settings.assets, settings.export?.assets ?? {});
        }

        settings.api = normalizeDomainAndContext(settings.api);
        settings.assets = normalizeDomainAndContext(settings.assets);

        return settings;

    } catch (error) {
        console.error(error);
        return false;
    }
};

/**
 * Method for loading the settings synchronous. The settings
 * need to be loaded with {@link loadSettings} before this
 * method can be used.
 *
 * @returns {boolean|*}
 */
const getSettings = () => settings;

const getConfigValue = (key, defaultValue = false) => {
    const parts = key.split('.');

    let setting = getSettings();
    for (const part of parts) {
        if (setting[part]) {
            setting = setting[part];
        } else {
            return defaultValue;
        }
    }
    return setting;
};

/**
 * Takes the fields from the settings object that can be
 * serialized and shared between server and client.
 *
 * @returns {boolean|{assets: {domain: *, context: string}, api: {domain: *, context: string}}}
 */
const getSerializableConfig = () => {
    if (!settings) {
        return false;
    }

    return {
        port: settings.port,

        assets: {
            domain: settings.assets.domain,
            context: settings.assets.context,
        },

        api: {
            domain: settings.api.domain,
            context: settings.api.context,
        }
    }
};

export { getPathToConfigFile, getSettings, getConfigValue, loadSettings, loadManifest, getSerializableConfig };
