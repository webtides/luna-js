import path from "path";
import fs from "fs";
import deepmerge from "deepmerge";
import defaultSettings from "./config/default.config";

let settings = false;

/**
 * Removes the trailing slash from the domain and from the context.
 * Adds a slash to the beginning of the context path.
 *
 * @param settings {{ domain: string, context: string }}
 *
 * @returns {{domain: *, context: string}}
 */
const normalizeDomainAndContext = (settings) => {
    let { domain, context } = settings;
    context = context || '';

    if (context.endsWith("/")) {
        context = context.substring(0, context.length - 1);
    }

    if (context.length > 0 && !context.startsWith("/")) {
        context = `/${context}`;
    }

    domain = domain || '';

    if (domain.endsWith("/")) {
        domain = domain.substring(0, domain.length - 1);
    }

    return Object.assign(settings, { domain, context });
};

/**
 * Loads the manifest generated by the cli.
 *
 * @param filename      Can either be the `manifest.json` or `manifest.client.json`, depending
*                       of the manifest that should be loaded.
 *
 * @returns {Promise<boolean|any>}
 */
const loadManifest = async (filename = "manifest.json") => {
    const settings = await loadSettings();

    const pathToManifest = path.join(settings._generated.baseDirectory, filename);

    if (fs.existsSync(pathToManifest)) {
        return JSON.parse(fs.readFileSync(pathToManifest, "utf-8"));
    }

    return false;
};

/**
 * Used to retrieve the path to the `luna.config.js`.
 *
 * @param currentWorkingDirectory string
 *
 * @returns {string}
 */
const getPathToConfigFile = (currentWorkingDirectory = process.cwd()) => {
    return path.join(currentWorkingDirectory, "luna.config.js");
}

/**
 * This method parses user settings from the `luna.config.js`.
 * Adds some more fields for generated paths. Anything that the user
 * can set or change should come from this settings object.
 *
 * @returns {Promise<*|boolean>}
 */
const loadSettings = async () => {
    if (settings) {
        return settings;
    }

    try {
        settings = deepmerge(defaultSettings, (await import(getPathToConfigFile())).default);

        settings.publicDirectory = path.join(settings.build.output, "public");

        settings._generated = {
            baseDirectory: path.join(settings.build.output, "generated"),
            applicationDirectory: path.join(settings.build.output, "generated", "application"),

            manifest: path.join(settings.build.output, "generated", "manifest.json"),
            clientManifest: path.join(settings.build.output, "generated", "manifest.client.json"),
        }

        /*
         * The cli sets the global flag isExporting if the user initialized an export.
         * Here we override the api and assets settings with the specific export settings.
         */
        // TODO: find some kind of plugin system to "connect" the cli and luna
        if (global.lunaCli?.isExporting === true) {
            settings.api = Object.assign(settings.api, settings.export?.api ?? {});
            settings.assets = Object.assign(settings.assets, settings.export?.assets ?? {});
        }

        settings.api = normalizeDomainAndContext(settings.api);
        settings.assets = normalizeDomainAndContext(settings.assets);

        return settings;

    } catch (error) {
        console.error(error);
        return false;
    }
};

/**
 * Method for loading the settings synchronous. The settings
 * need to be loaded with {@link loadSettings} before this
 * method can be used.
 *
 * @returns {boolean|*}
 */
const getSettings = () => settings;

const getConfigValue = (key, defaultValue = false) => {
    const parts = key.split('.');

    let setting = getSettings();
    for (const part of parts) {
        if (setting[part]) {
            setting = setting[part];
        } else {
            return defaultValue;
        }
    }
    return setting;
};

/**
 * Takes the fields from the settings object that can be
 * serialized and shared between server and client.
 *
 * @returns {boolean|{assets: {domain: *, context: string}, api: {domain: *, context: string}}}
 */
const getSerializableConfig = () => {
    if (!settings) {
        return false;
    }

    return {
        port: settings.port,

        assets: {
            domain: settings.assets.domain,
            context: settings.assets.context,
        },

        api: {
            domain: settings.api.domain,
            context: settings.api.context,
        }
    }
};

export { getPathToConfigFile, getSettings, getConfigValue, loadSettings, loadManifest, getSerializableConfig };
