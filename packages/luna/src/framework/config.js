import path from 'path';
import fs from 'fs';

const manifests = {};

/**
 * Loads the manifest generated by the cli.
 *
 * @param filename      Can either be the `manifest.json` or `manifest.client.json`, depending
 *                       of the manifest that should be loaded.
 *
 * @returns {boolean|any}
 */
const loadManifest = (filename = 'manifest.json') => {
	if (manifests[filename]) {
		return manifests[filename];
	}

	// TODO: in future we need to make this configurable.
	const pathToManifest = path.join('.build/generated', filename);

	if (fs.existsSync(pathToManifest)) {
		const manifest = JSON.parse(fs.readFileSync(pathToManifest, 'utf-8'));
		manifests[filename] = manifest;
		return manifest;
	}

	return false;
};

const getManifest = (filename = 'manifest.json') => {
	return loadManifest(filename);
};

const loadSettings = () => {
	const { settings } = loadManifest();
	return settings;
};

const getSettings = () => {
	return loadSettings();
};

const getConfigValue = (key, defaultValue = false) => {
	const parts = key.split('.');

	let setting = getSettings();
	for (const part of parts) {
		if (setting[part]) {
			setting = setting[part];
		} else {
			return defaultValue;
		}
	}
	return setting;
};

/**
 * Takes the fields from the settings object that can be
 * serialized and shared between server and client.
 *
 * @returns {boolean|{assets: {domain: *, context: string}, api: {domain: *, context: string}}}
 */
const getSerializableConfig = () => {
	const settings = loadSettings();

	return {
		port: settings.port,

		assets: {
			domain: settings.assets.domain,
			context: settings.assets.context,
		},

		api: {
			domain: settings.api.domain,
			context: settings.api.context,
		},
	};
};

export { getSettings, loadSettings, getManifest, loadManifest, getConfigValue, getSerializableConfig };
