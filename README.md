# moon-js

## Static Site Generation & SSR framework for custom-elements.

### Why?

The idea behind `moon-js` is to allow developers to rapidly create a full fledged
 web application using custom-elements with support for server side rendering.  
Under the hood it uses [@webtides/element-js](https://github.com/webtides/element-js), which is based
on the WebComponents standard.

## Installation

moon.js should be installed as a npm dependency. To install the module
add the following line to your dependencies and run `npm install`  
`"@webtides/moon-js": "git@github.com:webtides/moon-js.git"`.

## Getting started

`moon-js` ships with a command line tool. After installing `moon-js` as a dependency, you can simply run `moon --dev`
to start your application in development mode. If this is the first time you have started `moon-js`, you will be asked 
if `moon-js` should generate a config-file and a basic directory structure for you. 

## element-js concepts

You can read all about `element-js` here: [@webtides/element-js](https://github.com/webtides/element-js).

## moon-js concepts

`moon-js` uses the directory structure to automatically load the building blocks of your application.

### Configuration

`moon-js` uses a central configuration file at the root of your project to make itself familiar with your project
structure. The file is called `moon.config.js` and will be generated automatically the first time you run the `moon-js` 
cli.

Example moon.config.js:
```js
const path = require("path");

module.exports = {
    buildDirectory: ".build",
    publicDirectory: ".build/public",

    pagesDirectory: [ path.join(__dirname, "pages") ],

    componentsDirectory: [
        {
            basePath: path.join(__dirname),
            directory: "components",
            outputDirectory: ".build/public/assets",

            styles: {
                outputDirectory: ".build/public/assets/css",
                filename: "base.css",
                postcssPlugins: [ ]
            }
        }
    ],

    hooksDirectory: [ path.join(__dirname, "hooks") ],
    apisDirectory: [ path.join(__dirname, "api") ],

    /**
     * If true, the framework will build an additional bundle and polyfills needed for older browsers with
     * no full support of WebComponents.
     */
    legacyBuild: false,

    fallbackRoute: "/fallback",
    fallbackApiRoute: "/fallback",

    assets: {
        buildDirectory: ".build/public/assets",

        styles: {
            bundles: [ ]
        },

        static: {
            sources: []
        }
    },

    export: {
        outputDirectory: ".export",
        apiOutputDirectory: ".api"
    },
}
```

### Pages & Routes

By creating a file in your configured `Pages Directory`, you can register a new route. The name of the fill will be 
the name of the route.

If your `Pages Directory` is `app/pages` and you create a new file `home.js`, the route that is being registered
is `/home`.  
If you create a page inside a subdirectory, for example in `admin/dashboard.js`, the route that is being registered
is `/admin/dashboard`.  

To register the  `/`-route, the name of your file should be `index.js`.

*Example of a `moon-js` route:*
```js
// index.js
import { html } from "@webtides/moon-js";

export default () => {
    return html`
        <h1>Welcome to moon-js</h1>
    `;
};
```

### Layouts

Your can define a layout, which the page should extend. In a layout you can define which stylesheets or external
scripts should be loaded.

You need to make sure that you allow the page content to be rendered, by specifiying `context.page` and the 
scripts which are generated by `moon-js`.

*Example of a custom layout file:*
```js
import { html } from "@webtides/moon-js";

const layout = (page, context = {}) => {
    return html`
        <!doctype>
        <html>
            <head>
                <title>${context.title}</title>
            </head>
            <body>
                ${page}
            </body>
        </html>
    `;
};

export default layout;
```

*Example of a layout which extends the base layout provided by `moon-js`:*
```js
import { layouts, html } from "@webtides/moon-js";

const layout = (page, context = {}) => {

    context.head = [
        html`<link href="/assets/css/main.css" type="text/css" rel="stylesheet" />`,
        html`<meta name="viewport" content="width=device-width, initial-scale=1">`
    ];

    return layouts.base(page, context);
};

export default layout;
```

### Using a layout

If you want to use a different layout than the default one, you have to specifiy it in your pages.
To do this, simply define a named `layout` export.

```js
import { html } from "@webtides/moon-js";
import layout from "../layouts/base";
export { layout };

export default (() => {
    return html`
        <h1>Welcome to moon-js</h1>
    `;
});
```

### Passing information from the page to the layout

#### Using a anonymous page

Passing information to the layout using an anonymous page is straightforward. You have to
import your layout and then export the layout as a factory method using the context information
you require.

```js
import { html } from "@webtides/moon-js";
import layoutFactory from "../layouts/base";

const layout = async (page) => {
    const title = "My amazing page title";
    const data = await loadAsyncData();

    return layoutFactory(page, {
        title,
        data
    });
};

export { layout };

export default (() => {
    return html`
        <h1>Welcome to moon-js</h1>
    `;
});
```

#### Using page components

If you are using page components, the context information for the layout will be automatically
extracted from the component. The `this`-context of a component will be available in your layout.

```js
import {html, MoonElement} from "@webtides/moon-js";
import layout from "../layouts/base";

export { layout };

export default class ExamplePage extends MoonElement {
    title = "My amazing page title";

    constructor() {
        super();
    }

    template() {
        return html`
            <h1>HALLO</h1>
        `;
    }
}
```

### Components

Components are one of the core concepts of `moon-js`. They are based on [@webtides/element-js](https://github.com/webtides/element-js)
which is based on the WebComponents standard.

Components should be placed in a `Components Directory` specified in the `moon.config.js`.

#### Rendering Components

Components which render should extend the `MoonElement`, which extends the `StyledElement` from
[@webtides/element-js](https://github.com/webtides/element-js). You can use all available methods and concepts
from `element-js`.

Example component:
```js
import {MoonElement, html} from "@webtides/moon-js";

import "./header-element.css";

export default class HeaderElement extends MoonElement {

    template() {
        return html`
            <div class="flex items-center justify-between">
                <img class="w-32" src="/assets/images/logo.png" alt="Logo" />
                
                <button class="button">Warenkorb</button>
            </div>
        `;
    }
}
```

##### Additional class methods

```js
import {MoonElement, html} from "@webtides/moon-js";

export default class HeaderElement extends MoonElement {
    ...

    /**
     * An array of tag names this custom element has as children. Useful for when the element
     * is only rendered on the client, but we still need to inform the framework that it's children
     * should be loaded.
     *
     * @returns {string[]}
     */
    dependencies() { return []; }

    /**
     * This will be loaded each time the custom element is found on the page.
     * Make sure to really only load data which is unique for every element on the page.
     *
     * Here we can make calls to the database or any other service with data we require on each page load.
     *
     * If we are statically exporting the site, these properties won't ever be loaded.
     *
     * @param {*}
     *
     * @returns {Promise<{}>}   An object which holds the dynamically loaded data.
     *                          Make sure that each key returned by this method is also present
     *                          inside your {@link properties() } method. If a key is not
     *                          present, it won't be passed to the client.
     */
    async loadDynamicProperties({ request, response }) {
        return false;
    }


    /**
     * These properties will be loaded once as the server starts up, or if
     * we want to statically export our site.
     *
     * @returns {Promise<{}>}   An object which holds the statically loaded data.
     *                          Make sure that each key returned by this method is also present
     *                          inside your {@link properties() } method. If a key is not
     *                          present, it won't be passed to the client.
     */
    static async loadStaticProperties() {
        return false;
    }

    /**
     * Sets the element to be client side only. It won't be rendered on the server.
     * But it will be included, so all imports should be compatible with a node enironment.
     *
     * @returns {boolean}
     */
    static get disableSSR() { return false; }

    /**
     * The element will only be rendered on the server. The generated javascript won't be passed
     * to the client. Useful for elements which are not interactive.
     *
     * @returns {boolean}
     */
    static get disableCSR() { return false; }

    /**
     * Sets the dynamic properties to be cacheable. Normally the dynamic properties will be reloaded
     * on every request. With this flag they will only be loaded once and then cached.
     *
     * @returns {boolean}
     */
    static get dynamicPropertiesCacheable() { return false; }
}
```

#### Non-rendering components

Components that don't render can extends the `BaseElement` directly.

```js
import {BaseElement} from "@webtides/moon-js";

export default class ClientElement extends BaseElement {
    
    connected() {
        console.log("ClientElement has connected.");
    }
}
```


### APIs

Api routes can be created the same way as page routes. To register an api route, just create 
a file inside your `Api Directory`.

All api routes will be prefixed with `api`. If you create a `users.js` inside the root of your `Api directory`
the final url will be `/api/users`.

#### Get request

Example of a basic route which will react on a get request.
```js
export default async ({ request, response }) => {
    return response.json({ result: "success" });
}
```
#### Post request
Example of a basic route which will react on a post request.
```js
const post = async ({ request, response }) => {
    return response.json({ result: "success" });
};

export { post };
```

#### Mixed requests

```js
const post = async ({ request, response }) => {
    return response.json({ result: "get success" });
};

const get = async ({ request, response }) => {
    return response.json({ result: "post success" });
};

export { post, get };
```

### Hooks

To extend functionality and to react on certain events, `moon-js` introduces a hook system. You have
multiple of hooks available. To register a hook, create a file in your `Hooks Directory`.

Example of the `SERVER_STARTED` hook:
```js
import {HOOKS} from "@webtides/moon-js/lib/packages/framework/hooks/definitions";

const name = HOOKS.SERVER_STARTED;
export { name };

export default () => {
    console.log("Express server has started");
};
```

Example of the `REQUEST_RECEIVED` hook:
```js
import {HOOKS} from "@webtides/moon-js/lib/packages/framework/hooks/definitions";

const name = HOOKS.REQUEST_RECEIVED;
export { name };

export default ({ request, response }) => {
    console.log("Request received.");
};
```

A hook can receive additional parameters.

#### List of available hooks

 - `HOOKS_LOADED`: Will be called right after all hooks have been loaded.
 
 - `COMPONENTS_LOADED`: Called after all available components habe been loaded.  
    Parameters:
    - `components`: An array of all available components
    
 - `ROUTES_BEFORE_REGISTER`: Called before the page and api routes will be registered.  
    Parameters:  
    - `router`: The express app instance.
    
 - `MIDDLEWARE_REGISTER`: Here you can register additional express middleware.  
    Parameters: 
    - `app`: The express app instance.
    
 - `ROUTES_AFTER_REGISTER`: Called after the page and api routes have been registered.  
    Parameters:
    - `router`: The express app instance.
    
 - `REQUEST_RECEIVED`: Will be called on every request, before passing the request to the route,
 but after the middleware registered in the `MIDDLEWARE_REGISTER` hook.
    Parameters:
    - `request`: The express request object.
    - `response`: The express response object.


### Rendering

Rendering on the client and on the server is done by [lit-html](https://lit-html.polymer-project.org/).


## Static site generator

Using `moon-js` as a static site generator is possible, too. 
The following command exports you complete application as a static site:
```
moon --export
```

Before you can export your site, you have to set you `outputDirectory` inside
your `moon.config.js`.

```
{
    ...,
    export: {
        outputDirectory: ".export"    
    },
    ...
}
```

### Gotchas

The `loadDynamicProperties` method cannot be called in a static context. If you export
your application as a static site this method will be ignored.


## Api generator

`moon-js` also allows you to export your api routes as a standalone express
application. This will only export your api, without any frontend assets.

To generate an api server, you can use the follwing command:

```
moon --export=api
```
Before you can export your api, you have to set your `apiOutputDirectory` inside
your `moon.config.js`. If `apiOutputDirectory` is not set, `moon-js` will fall back
to `outputDirectory`.

```
{
    ...,
    export: {
        outputDirectory: ".export",
        apiOutputDirectory: ".api"
    },
    ...
}
```

### Hybrid export

A hybric export is useful for serverless environments or if you generated
your static site, but don't want to loose all your serverside functionality.
`moon-js` will generate a static site and export an express application
which is configured to serve your exported static site and your api.


To generate a hybrid export run:

```
moon --export=hybrid
```

### Serverless

Exporting your api or hybrid api to a serverless environment is as easy as passing the 
additional `--serverless` flag to your export command.

```
moon --export=hybrid --serverless // or
moon --export=api --serverless
```

You may have to install your npm dependencies in your exported directory.

#### Gotchas

The `loadDynamicProperties` method cannot be called in a static context. If make a hybrid
 export of your application this method will be ignored.

## Additional features

### Postcss

You can import (post)css files directly into your components and `moon-js` will generate
a bundle with all imported css files. The bundle name can be specified in the `moon.config.js`.

### Markdown

You can import markdown files with frontmatter in your application. `moon-js` will read 
them and return them as a html string for you to use.

## License 

MIT License
